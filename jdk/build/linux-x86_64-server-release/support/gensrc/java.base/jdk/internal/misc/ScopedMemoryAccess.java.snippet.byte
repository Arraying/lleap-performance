    @ForceInline
    public byte getByte(MemorySessionImpl session, Object base, long offset) {
        try {
            return getByteInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getByteInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getByte(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putByte(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            putByteInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putByteInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putByte(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }


    @ForceInline
    public byte getByteVolatile(MemorySessionImpl session, Object base, long offset) {
        try {
            return getByteVolatileInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getByteVolatileInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getByteVolatile(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putByteVolatile(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            putByteVolatileInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putByteVolatileInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putByteVolatile(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getByteAcquire(MemorySessionImpl session, Object base, long offset) {
        try {
            return getByteAcquireInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getByteAcquireInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getByteAcquire(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putByteRelease(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            putByteReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putByteRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getByteOpaque(MemorySessionImpl session, Object base, long offset) {
        try {
            return getByteOpaqueInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getByteOpaqueInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getByteOpaque(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
    @ForceInline
    public void putByteOpaque(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            putByteOpaqueInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putByteOpaqueInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putByteOpaque(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
    @ForceInline
    public boolean compareAndSetByte(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return compareAndSetByteInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean compareAndSetByteInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndSetByte(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte compareAndExchangeByte(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return compareAndExchangeByteInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte compareAndExchangeByteInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeByte(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte compareAndExchangeByteAcquire(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return compareAndExchangeByteAcquireInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte compareAndExchangeByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeByteAcquire(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte compareAndExchangeByteRelease(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return compareAndExchangeByteReleaseInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte compareAndExchangeByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeByteRelease(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetBytePlain(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return weakCompareAndSetBytePlainInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetBytePlainInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetBytePlain(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetByte(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return weakCompareAndSetByteInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetByteInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetByte(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetByteAcquire(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return weakCompareAndSetByteAcquireInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetByteAcquire(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetByteRelease(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            return weakCompareAndSetByteReleaseInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte expected, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetByteRelease(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndSetByte(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndSetByteInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndSetByteInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetByte(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndSetByteAcquire(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndSetByteAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndSetByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetByteAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndSetByteRelease(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndSetByteReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndSetByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetByteRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndAddByte(MemorySessionImpl session, Object base, long offset, byte delta) {
        try {
            return getAndAddByteInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndAddByteInternal(MemorySessionImpl session, Object base, long offset, byte delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddByte(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndAddByteAcquire(MemorySessionImpl session, Object base, long offset, byte delta) {
        try {
            return getAndAddByteAcquireInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndAddByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddByteAcquire(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndAddByteRelease(MemorySessionImpl session, Object base, long offset, byte delta) {
        try {
            return getAndAddByteReleaseInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndAddByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddByteRelease(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseOrByte(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseOrByteInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseOrByteInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrByte(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseOrByteAcquire(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseOrByteAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseOrByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrByteAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseOrByteRelease(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseOrByteReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseOrByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrByteRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseAndByte(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseAndByteInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseAndByteInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndByte(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseAndByteAcquire(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseAndByteAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseAndByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndByteAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseAndByteRelease(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseAndByteReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseAndByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndByteRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseXorByte(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseXorByteInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseXorByteInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorByte(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseXorByteAcquire(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseXorByteAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseXorByteAcquireInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorByteAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public byte getAndBitwiseXorByteRelease(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            return getAndBitwiseXorByteReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private byte getAndBitwiseXorByteReleaseInternal(MemorySessionImpl session, Object base, long offset, byte value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorByteRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
