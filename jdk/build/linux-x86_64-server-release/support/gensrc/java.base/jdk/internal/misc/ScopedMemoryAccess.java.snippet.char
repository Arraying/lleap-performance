    @ForceInline
    public char getChar(MemorySessionImpl session, Object base, long offset) {
        try {
            return getCharInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getCharInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getChar(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putChar(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            putCharInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putCharInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putChar(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getCharUnaligned(MemorySessionImpl session, Object base, long offset, boolean be) {
        try {
            return getCharUnalignedInternal(session, base, offset, be);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getCharUnalignedInternal(MemorySessionImpl session, Object base, long offset, boolean be) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getCharUnaligned(base, offset, be);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putCharUnaligned(MemorySessionImpl session, Object base, long offset, char value, boolean be) {
        try {
            putCharUnalignedInternal(session, base, offset, value, be);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putCharUnalignedInternal(MemorySessionImpl session, Object base, long offset, char value, boolean be) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putCharUnaligned(base, offset, value, be);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getCharVolatile(MemorySessionImpl session, Object base, long offset) {
        try {
            return getCharVolatileInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getCharVolatileInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getCharVolatile(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putCharVolatile(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            putCharVolatileInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putCharVolatileInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putCharVolatile(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getCharAcquire(MemorySessionImpl session, Object base, long offset) {
        try {
            return getCharAcquireInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getCharAcquireInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getCharAcquire(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putCharRelease(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            putCharReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putCharRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getCharOpaque(MemorySessionImpl session, Object base, long offset) {
        try {
            return getCharOpaqueInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getCharOpaqueInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getCharOpaque(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
    @ForceInline
    public void putCharOpaque(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            putCharOpaqueInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putCharOpaqueInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putCharOpaque(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
    @ForceInline
    public boolean compareAndSetChar(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return compareAndSetCharInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean compareAndSetCharInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndSetChar(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char compareAndExchangeChar(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return compareAndExchangeCharInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char compareAndExchangeCharInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeChar(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char compareAndExchangeCharAcquire(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return compareAndExchangeCharAcquireInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char compareAndExchangeCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeCharAcquire(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char compareAndExchangeCharRelease(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return compareAndExchangeCharReleaseInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char compareAndExchangeCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeCharRelease(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetCharPlain(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return weakCompareAndSetCharPlainInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetCharPlainInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetCharPlain(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetChar(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return weakCompareAndSetCharInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetCharInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetChar(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetCharAcquire(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return weakCompareAndSetCharAcquireInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetCharAcquire(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetCharRelease(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            return weakCompareAndSetCharReleaseInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char expected, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetCharRelease(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndSetChar(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndSetCharInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndSetCharInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetChar(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndSetCharAcquire(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndSetCharAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndSetCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetCharAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndSetCharRelease(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndSetCharReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndSetCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetCharRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndAddChar(MemorySessionImpl session, Object base, long offset, char delta) {
        try {
            return getAndAddCharInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndAddCharInternal(MemorySessionImpl session, Object base, long offset, char delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddChar(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndAddCharAcquire(MemorySessionImpl session, Object base, long offset, char delta) {
        try {
            return getAndAddCharAcquireInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndAddCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddCharAcquire(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndAddCharRelease(MemorySessionImpl session, Object base, long offset, char delta) {
        try {
            return getAndAddCharReleaseInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndAddCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddCharRelease(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseOrChar(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseOrCharInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseOrCharInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrChar(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseOrCharAcquire(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseOrCharAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseOrCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrCharAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseOrCharRelease(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseOrCharReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseOrCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrCharRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseAndChar(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseAndCharInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseAndCharInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndChar(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseAndCharAcquire(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseAndCharAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseAndCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndCharAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseAndCharRelease(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseAndCharReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseAndCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndCharRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseXorChar(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseXorCharInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseXorCharInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorChar(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseXorCharAcquire(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseXorCharAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseXorCharAcquireInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorCharAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public char getAndBitwiseXorCharRelease(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            return getAndBitwiseXorCharReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private char getAndBitwiseXorCharReleaseInternal(MemorySessionImpl session, Object base, long offset, char value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorCharRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
