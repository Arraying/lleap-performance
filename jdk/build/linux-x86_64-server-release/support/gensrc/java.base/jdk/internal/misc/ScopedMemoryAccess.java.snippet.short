    @ForceInline
    public short getShort(MemorySessionImpl session, Object base, long offset) {
        try {
            return getShortInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getShortInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getShort(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putShort(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            putShortInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putShortInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putShort(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getShortUnaligned(MemorySessionImpl session, Object base, long offset, boolean be) {
        try {
            return getShortUnalignedInternal(session, base, offset, be);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getShortUnalignedInternal(MemorySessionImpl session, Object base, long offset, boolean be) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getShortUnaligned(base, offset, be);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putShortUnaligned(MemorySessionImpl session, Object base, long offset, short value, boolean be) {
        try {
            putShortUnalignedInternal(session, base, offset, value, be);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putShortUnalignedInternal(MemorySessionImpl session, Object base, long offset, short value, boolean be) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putShortUnaligned(base, offset, value, be);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getShortVolatile(MemorySessionImpl session, Object base, long offset) {
        try {
            return getShortVolatileInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getShortVolatileInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getShortVolatile(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putShortVolatile(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            putShortVolatileInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putShortVolatileInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putShortVolatile(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getShortAcquire(MemorySessionImpl session, Object base, long offset) {
        try {
            return getShortAcquireInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getShortAcquireInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getShortAcquire(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public void putShortRelease(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            putShortReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putShortRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getShortOpaque(MemorySessionImpl session, Object base, long offset) {
        try {
            return getShortOpaqueInternal(session, base, offset);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getShortOpaqueInternal(MemorySessionImpl session, Object base, long offset) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getShortOpaque(base, offset);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
    @ForceInline
    public void putShortOpaque(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            putShortOpaqueInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private void putShortOpaqueInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            UNSAFE.putShortOpaque(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
    @ForceInline
    public boolean compareAndSetShort(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return compareAndSetShortInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean compareAndSetShortInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndSetShort(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short compareAndExchangeShort(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return compareAndExchangeShortInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short compareAndExchangeShortInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeShort(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short compareAndExchangeShortAcquire(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return compareAndExchangeShortAcquireInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short compareAndExchangeShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeShortAcquire(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short compareAndExchangeShortRelease(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return compareAndExchangeShortReleaseInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short compareAndExchangeShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.compareAndExchangeShortRelease(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetShortPlain(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return weakCompareAndSetShortPlainInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetShortPlainInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetShortPlain(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetShort(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return weakCompareAndSetShortInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetShortInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetShort(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetShortAcquire(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return weakCompareAndSetShortAcquireInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetShortAcquire(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public boolean weakCompareAndSetShortRelease(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            return weakCompareAndSetShortReleaseInternal(session, base, offset, expected, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private boolean weakCompareAndSetShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short expected, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.weakCompareAndSetShortRelease(base, offset, expected, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndSetShort(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndSetShortInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndSetShortInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetShort(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndSetShortAcquire(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndSetShortAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndSetShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetShortAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndSetShortRelease(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndSetShortReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndSetShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndSetShortRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndAddShort(MemorySessionImpl session, Object base, long offset, short delta) {
        try {
            return getAndAddShortInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndAddShortInternal(MemorySessionImpl session, Object base, long offset, short delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddShort(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndAddShortAcquire(MemorySessionImpl session, Object base, long offset, short delta) {
        try {
            return getAndAddShortAcquireInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndAddShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddShortAcquire(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndAddShortRelease(MemorySessionImpl session, Object base, long offset, short delta) {
        try {
            return getAndAddShortReleaseInternal(session, base, offset, delta);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndAddShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short delta) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndAddShortRelease(base, offset, delta);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseOrShort(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseOrShortInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseOrShortInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrShort(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseOrShortAcquire(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseOrShortAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseOrShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrShortAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseOrShortRelease(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseOrShortReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseOrShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseOrShortRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseAndShort(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseAndShortInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseAndShortInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndShort(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseAndShortAcquire(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseAndShortAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseAndShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndShortAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseAndShortRelease(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseAndShortReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseAndShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseAndShortRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseXorShort(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseXorShortInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseXorShortInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorShort(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseXorShortAcquire(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseXorShortAcquireInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseXorShortAcquireInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorShortAcquire(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }

    @ForceInline
    public short getAndBitwiseXorShortRelease(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            return getAndBitwiseXorShortReleaseInternal(session, base, offset, value);
        } catch (ScopedAccessError ex) {
            throw ex.newRuntimeException();
        }
    }

    @ForceInline @Scoped
    private short getAndBitwiseXorShortReleaseInternal(MemorySessionImpl session, Object base, long offset, short value) {
        try {
            if (session != null) {
                session.checkValidStateRaw();
            }
            return UNSAFE.getAndBitwiseXorShortRelease(base, offset, value);
        } finally {
            Reference.reachabilityFence(session);
        }
    }
